確認時の環境

    $ ruby -v

    ruby 1.9.3p327 (2012-11-10 revision 37606) [x86_64-darwin12.2.0]

# Hash

ハッシュテーブルや連想配列と呼ばれるデータ構造を表現するクラス。
キーとなるオブジェクトと値となるオブジェクトの関連付けを行ない。キーオブジェクトがあれば値オブジュクトを取り出すことができる

http://rurema.clear-code.com/1.9.3/class/Hash.html

ハッシュにはリテラルが用意されている。

    { [key] => [value], [key] => [value] }

の形式で記述できる
keyが以下のようなシンボルの場合は

    { :key1 => value1, :key2 => value2 }

以下のように書き換えができる

    { key1: value1, key2: value2 }

メソッドの引数とするときなどには 波括弧を省略できる場合がある。
(などってかいたけど他にもあるっけ？)

Hash のキーになるオブジェクト は hash eql? メソッドが適切に定義してある必要がある。

文字列を key に使う場合はコピーを行い変更を行えないようにして、キーにするので、このようなオーバヘッドを防ぎたい場合は Symbolのインスタンスをキーにするのが一般的。

Enumerable モジュールをインクルードしとる。

# 特異メソッド

なぜクラスメソッドじゃないのだろう。

## []

[サンプルコード](bracket.rb)

- 引数がHash の場合 Hashをコピー
- 引数が複数個 の場合 キー 値 キー 値の 順番でハッシュを作る
- 引数が奇数個 の場合 例外が発生する

## new

[サンプルコード](new.rb)

- 無引数で空のHashが作れる
- 引数を渡すことでキーがない場合のデフォルト値を設定できる
  - このときデフォルに使うオブジェクトは同じものを使うため破壊的操作をすると…
- ブロックを渡すことでキーがない場合の処理を記述できる

## try_convert

- to_hashを使用して hashに変換できるかを確認する。
- 引数をHash前提でうけとってる場合とかに便利げ？
- みたことなかった…

# インスタンスメソッド

## ==, ===, eql?

[サンプルコード](eql.rb)

- 以下の場合 true を返す
  - キーが同じ数
  - それぞれのキーが eql? で一致
  - それぞれの値が == で一致

## []

- キーに関連付いた値を取り出す
- キーがない場合はデフォルト
- キーがない場合を確認するには fetch や has_key? を

## []=, store

- キーに値を関連付ける
- storeというエイリアスがある


## assoc

[サンプルコード](assoc.rb)

- キートキーに関連した値とのペアを配列で返す

## clear

[サンプルコード](clear.rb)

- Hash の中身を空にする

## compare_by_identity

[サンプルコード](compare_by_idenntity.rb)

- ハッシュのキーの一致判定を同じオブジェクトかどうかで判定するようになる
- ハッシュ自体が破壊的メソッド
- もどすには？


## compare_by_identity?

[サンプルコード](compare_by_idenntity.rb)

- compare\_by\_identyty が有効かどうか判定する

## default

[サンプルコード](default.rb)

- デフォルト値を取得する


## default=

[サンプルコード](default.rb)

- デフォルト値を変更する
- 値をセットすると default_proc は nil になるっぽい

## default_proc

[サンプルコード](default.rb)

- キーがない場合の処理を取得する

## default_proc=

[サンプルコード](default.rb)

- キーがない場合の処理を登録する
- 値をセットすると default は nil になるっぽい

## delete

[サンプルコード](delete.rb)

- キーを削除する
- 当然、値もなくなる
- 削除した値を返す
- キーがない場合は nil を返す
- ブロックを渡すことで、キーがない場合はブロックを実行できる。

## delete_if, reject!

[サンプルコード](delete_if.rb)

- Enumerableの delete_if ようなもの ブロックに keyとvalue が渡る
- ブロックの戻り値が true なら その要素は削除される

## each, each_pair

[サンプルコード](each.rb)

- each の ハッシュ版

## each_key

[サンプルコード](each.rb)

- キーだけで each


## each_value

[サンプルコード](each.rb)

- 値だけで each


## empty?

[サンプルコード](empty.rb)

- ハッシュが空のときに true を返す

## fetch

[サンプルコード](fetch.rb)

- 与えられたキーがなかったときの動作をその場で指定できる
- 値を渡せばその値を返す
- ブロックを渡せば処理を評価する

## flatten

[サンプルコード](flatten.rb)

- 配列に平滑化する
- レベルを指定すると指定した数だけ再帰的に平滑化
- 1 がデフォルト
- 0 だと連想リストのように
- -1 を指定すると再帰的に処理する
- 内部にあるHashを flatten にするわけではない。


## has_key?, include?, key?, member?

- キーをもっているかどうか確認する

## has_value?, value?

- ある値を持っているか確認する

## invert

[サンプルコード](invert.rb)

- キーと値を入れかえる
- 値が重複してる場合は不定
- 本環境では後ろにあるもので上書きされた

## keep_if, select!

[サンプルコード](keep_if.rb)

- 渡したブロックが真を返すものだけ集める
- keep_ifと select! で動作が違う
  - 何もおきなかった場合は select! の場合 nil を返す

## keys

- キーの配列を返す

## length

- 要素の数を返す

## merge, merge!

- ふたつのhashを統合します。default値は self のものが使用される
- merge! はselfを上書きする

## rassoc

[サンプルコード](assoc.rb)

- assocはキーに対してだけど rassoc は 値に対して行う

## rehash

[サンプルコード](rehash.rb)

- キーの再計算を行う
- キーに使用したオブジェクトが変更されている場合に行う

## replace

[サンプルコード](replace.rb)

- ハッシュの内容を置き換える
- 引数が Hash でない場合は to_hash による変換を試みる
- 使いどころがわからない…

## shift

[サンプルコード](shift.rb)

- ハッシュから キーと値 を取り除く
- 取り除いた値を替えす
- 順番は不定らしいけど 1.9 でも不定なのか気になるが…
- 値がない場合はデフォルト値を返す

## to_hash

- 自分自身を返す

## update

- 基本的に merge!
- ブロックで処理を追加可能
- 同じキーがあるときに有効

## values

- 値の配列を返します

## values_at

[サンプルコード](values_at.rb)

- 引数に指定した key の一覧をもとに値の配列を返す

# まとめ

- flatten しらんかった
  - -1 についての説明があってもいいかも
- fetch わすれてた
- assoc しらんかった
- rehash でHashの構造がみえてきそう？
- sortはenumerableで実装っぽい
